/////////// Floods in Tana River Basin
var alos = ee.Image("JAXA/ALOS/AW3D30/V2_2");
Map.centerObject(AOI, 8)

/**
 * Function to mask clouds using the Sentinel-2 QA band
 * @param {ee.Image} image Sentinel-2 image
 * @return {ee.Image} cloud masked Sentinel-2 image 
 */
function maskS2clouds(image) {
  var qa = image.select('QA60');  

  // Bits 10 and 11 are clouds and cirrus, respectively.
  var cloudBitMask = 1 << 10;
  var cirrusBitMask = 1 << 11;

  // Both flags should be set to zero, indicating clear conditions.
  var mask = qa.bitwiseAnd(cloudBitMask).eq(0)
      .and(qa.bitwiseAnd(cirrusBitMask).eq(0));

  return image.updateMask(mask).divide(10000);
}

//******************************      2021      ****************************************//////

/////////// Time before floods 

var Time2021_before = ic_s2.filterDate("2021-01-01", "2021-03-14")
                        .filterMetadata("CLOUDY_PIXEL_PERCENTAGE", "less_than", 40)
                        .map(maskS2clouds)
                        .median()
                        .clip(AOI)
    
/////////// Time after floods
                        
var Time2021_after = ic_s2.filterDate("2021-03-26", "2021-05-26")
                        .filterMetadata("CLOUDY_PIXEL_PERCENTAGE", "less_than", 40)
                        .map(maskS2clouds)
                        .median()
                        .clip(AOI)
                        


////////// Modified Normalized Difference Water Index (NDWI)

var after2021_flood = Time2021_after.normalizedDifference(["B3", "B11"]).rename("MNDWI")
var before2021_flood = Time2021_before.normalizedDifference(["B3", "B11"]).rename("MNDWI")



//******************************      2020      ****************************************//////

/////////// Time before floods 

var Time2020_before = ic_s2.filterDate("2020-01-25", "2020-04-09")
                        .filterMetadata("CLOUDY_PIXEL_PERCENTAGE", "less_than", 40)
                        .map(maskS2clouds)
                        .median()
                        .clip(AOI)
    
/////////// Time after floods
                        
var Time2020_after = ic_s2.filterDate("2020-04-11", "2020-06-30")
                        .filterMetadata("CLOUDY_PIXEL_PERCENTAGE", "less_than", 40)
                        .map(maskS2clouds)
                        .median()
                        .clip(AOI)
                        

/////////// 2020 RGB COMPOSITE

var filtered2020 = ic_s2.filterDate("2020-01-01", "2020-12-31")
                  .filterMetadata("CLOUDY_PIXEL_PERCENTAGE", "less_than", 40)
                        .map(maskS2clouds)
                        //.median()
                        //.clip(AOI);


var composite2020 = filtered2020.median().clip(AOI)

var addIndices = function(image) {
  var ndvi = image.normalizedDifference(['B8', 'B4']).rename(['ndvi']);
  var ndbi = image.normalizedDifference(['B11', 'B8']).rename(['ndbi']);
  var mndwi = image.normalizedDifference(['B3', 'B11']).rename(['mndwi']); 
  var bsi = image.expression(
      '(( X + Y ) - (A + B)) /(( X + Y ) + (A + B)) ', {
        'X': image.select('B11'), //swir1
        'Y': image.select('B4'),  //red
        'A': image.select('B8'), // nir
        'B': image.select('B2'), // blue
  }).rename('bsi');
  return image.addBands(ndvi).addBands(ndbi).addBands(mndwi).addBands(bsi)
}

var composite2020 = addIndices(composite2020);


var elev = alos.select('AVE_DSM').divide(2000).rename('elev');
var slope = ee.Terrain.slope(alos.select('AVE_DSM')).divide(30).rename('slope');

var composite2020 = composite2020.addBands(elev).addBands(slope);

//////////*********** Modified Normalized Difference Water Index (NDWI)    ********///////////////

var after2020_flood = Time2020_after.normalizedDifference(["B3", "B11"]).rename("MNDWI")
var before2020_flood = Time2020_before.normalizedDifference(["B3", "B11"]).rename("MNDWI")

Map.addLayer(composite2020, {min:0, max:0.3, bands:['B4', 'B3', 'B2']}, '2020 RGB Composite', false)

//////////**********************     2020 CLASSIFICATION    *****************//////////////

var bands = ["B2", "B3", "B4", "B8", "B8A", "B11"]

var gcps = Tana.merge(Grassland).merge(Bareland).merge(Bushland).merge(Cropland).merge(Settlement).merge(Shrubs)

// Add a random column and split the GCPs into training and validation set
var TGCP = gcps.randomColumn()

// This being a simpler classification, we take 70% points
// for validation. Normal recommended ratio is
// 70% training, 30% validation
var trainingGcp = TGCP.filter(ee.Filter.lt('random', 0.7));
var validationGcp = TGCP.filter(ee.Filter.gte('random', 0.7));



// Overlay the point on the image to get training data.
var training = composite2020.sampleRegions({
  collection: trainingGcp, 
  properties: ['landcover'], 
  scale: 20,
  tileScale: 16
});



// Train a classifier.
var classifier = ee.Classifier.smileRandomForest(10).train({
  features: training,  
  classProperty: 'landcover', 
  inputProperties: bands
});
// // Classify the image.
//var classified2020 = composite.select(bands).classify(classifier)
var classified2020 = composite2020.classify(classifier);
Map.addLayer(classified2020, {min: 0, max: 6, palette: ['00FFFF', 'F0E68C', 'b4b4b4', '006400', 'f096ff', 'A52A2A', 'ffbb22']}, '2020 Classified Map', false);

Export.image.toDrive({
  image: classified2020,
  description:'TANA_RIVER_BASIN_CLASSIFIED_2020',
  scale: 20,
  region: AOI,
}); 

/////////////////////////////////////////////////////////////////////////////////
//____________________3)  ACCURACY ASSESSMENT SECTION_____________________________//
//////////////////////////////////////////////////////////////////////////////////


//Validation data is sampled from the classified image with regard
//to the validation points.
var validation = classified2020.sampleRegions({
    //The validation features from which validation data is sampled
    collection: Tana,
    //property name in the validation features that contain the classification label
    properties: ['landcover'],
    scale: 10
  });
  //print('Validation', validation);
  
  // compare the landcover of your validation data against the classification results
  
  var testAccuracy = validation.errorMatrix('landcover', 'classification');
  
  //  print the error matrix to the console
  
  print('Confusion Matrix:', testAccuracy);
  
  
  
  //print overall accuracy and Kappa value to the console
  
  print('Overall Accuracy:',testAccuracy.accuracy().multiply(100));
  
